{"version":3,"file":"parcel.cjs","sources":["../../src/single-spa-react.js","../../src/parcel.js"],"sourcesContent":["/* We don't import parcel.component.js from this file intentionally. See comment\n * in that file for why\n */\n\n// React context that gives any react component the single-spa props\nexport let SingleSpaContext = null;\n\n// This try/catch exists mostly to prevent rollup from thinking that SingleSpaContext\n// is null and then doing optimizations in parcel.js that cause bugs.\n// See https://github.com/single-spa/single-spa-react/issues/105\n\ntry {\n  // single-spa-react is usable as a global script, as a systemjs module, and other\n  // situations where require() is unavailable. This is why we require the user to\n  // pass in opts.React and opts.ReactDOM - to avoid the mess of \"how do i properly load react\".\n  // However, in situations where require() is available, we can use it this way to create\n  // the react context. The try/catch defensiveness keeps single-spa-react working in\n  // as many situations as possible.\n  SingleSpaContext = require(\"react\").createContext();\n} catch {\n  // ignore\n}\n\nconst defaultOpts = {\n  // required opts\n  React: null,\n  ReactDOM: null,\n\n  // required - one or the other\n  rootComponent: null,\n  loadRootComponent: null,\n\n  // optional opts\n  renderType: null,\n  errorBoundary: null,\n  errorBoundaryClass: null,\n  domElementGetter: null,\n  parcelCanUpdate: true, // by default, allow parcels created with single-spa-react to be updated\n  suppressComponentDidCatchWarning: false,\n  domElements: {},\n};\n\nexport default function singleSpaReact(userOpts) {\n  if (typeof userOpts !== \"object\") {\n    throw new Error(`single-spa-react requires a configuration object`);\n  }\n\n  const opts = {\n    ...defaultOpts,\n    ...userOpts,\n  };\n\n  if (!opts.React) {\n    throw new Error(`single-spa-react must be passed opts.React`);\n  }\n\n  if (!opts.ReactDOM) {\n    throw new Error(`single-spa-react must be passed opts.ReactDOM`);\n  }\n\n  if (!opts.rootComponent && !opts.loadRootComponent) {\n    throw new Error(\n      `single-spa-react must be passed opts.rootComponent or opts.loadRootComponent`\n    );\n  }\n\n  if (opts.errorBoundary && typeof opts.errorBoundary !== \"function\") {\n    throw Error(\n      `The errorBoundary opt for single-spa-react must either be omitted or be a function that returns React elements`\n    );\n  }\n\n  if (!SingleSpaContext && opts.React.createContext) {\n    SingleSpaContext = opts.React.createContext();\n  }\n\n  const lifecycles = {\n    bootstrap: bootstrap.bind(null, opts),\n    mount: mount.bind(null, opts),\n    unmount: unmount.bind(null, opts),\n  };\n\n  if (opts.parcelCanUpdate) {\n    lifecycles.update = update.bind(null, opts);\n  }\n\n  return lifecycles;\n}\n\nfunction bootstrap(opts, props) {\n  if (opts.rootComponent) {\n    // This is a class or stateless function component\n    return Promise.resolve();\n  } else {\n    // They passed a promise that resolves with the react component. Wait for it to resolve before mounting\n    return opts.loadRootComponent(props).then((resolvedComponent) => {\n      opts.rootComponent = resolvedComponent;\n    });\n  }\n}\n\nfunction mount(opts, props) {\n  return new Promise((resolve, reject) => {\n    if (\n      !opts.suppressComponentDidCatchWarning &&\n      atLeastReact16(opts.React) &&\n      !opts.errorBoundary\n    ) {\n      if (!opts.rootComponent.prototype) {\n        console.warn(\n          `single-spa-react: ${\n            props.name || props.appName || props.childAppName\n          }'s rootComponent does not implement an error boundary.  If using a functional component, consider providing an opts.errorBoundary to singleSpaReact(opts).`\n        );\n      } else if (!opts.rootComponent.prototype.componentDidCatch) {\n        console.warn(\n          `single-spa-react: ${\n            props.name || props.appName || props.childAppName\n          }'s rootComponent should implement componentDidCatch to avoid accidentally unmounting the entire single-spa application.`\n        );\n      }\n    }\n\n    const domElementGetter = chooseDomElementGetter(opts, props);\n\n    if (typeof domElementGetter !== \"function\") {\n      throw new Error(\n        `single-spa-react: the domElementGetter for react application '${\n          props.appName || props.name\n        }' is not a function`\n      );\n    }\n\n    const whenFinished = function () {\n      resolve(this);\n    };\n\n    const elementToRender = getElementToRender(opts, props);\n    const domElement = getRootDomEl(domElementGetter, props);\n    const renderedComponent = reactDomRender({\n      elementToRender,\n      domElement,\n      whenFinished,\n      opts,\n    });\n    opts.domElements[props.name] = domElement;\n  });\n}\n\nfunction unmount(opts, props) {\n  return Promise.resolve().then(() => {\n    opts.ReactDOM.unmountComponentAtNode(opts.domElements[props.name]);\n    delete opts.domElements[props.name];\n  });\n}\n\nfunction update(opts, props) {\n  return new Promise((resolve, reject) => {\n    const whenFinished = function () {\n      resolve(this);\n    };\n\n    const elementToRender = getElementToRender(opts, props);\n    const renderedComponent = reactDomRender({\n      elementToRender,\n      domElement: opts.domElements[props.name],\n      whenFinished,\n      opts,\n    });\n  });\n}\n\nfunction getRootDomEl(domElementGetter, props) {\n  const el = domElementGetter(props);\n  if (!el) {\n    throw new Error(\n      `single-spa-react: domElementGetter function for application '${\n        props.appName || props.name\n      }' did not return a valid dom element. Please pass a valid domElement or domElementGetter via opts or props`\n    );\n  }\n\n  return el;\n}\n\nfunction atLeastReact16(React) {\n  if (\n    React &&\n    typeof React.version === \"string\" &&\n    React.version.indexOf(\".\") >= 0\n  ) {\n    const majorVersionString = React.version.slice(\n      0,\n      React.version.indexOf(\".\")\n    );\n    try {\n      return Number(majorVersionString) >= 16;\n    } catch (err) {\n      return false;\n    }\n  } else {\n    return false;\n  }\n}\n\nfunction chooseDomElementGetter(opts, props) {\n  if (props.domElement) {\n    return () => props.domElement;\n  } else if (props.domElementGetter) {\n    return props.domElementGetter;\n  } else if (opts.domElementGetter) {\n    return opts.domElementGetter;\n  } else {\n    return defaultDomElementGetter(props);\n  }\n}\n\nfunction defaultDomElementGetter(props) {\n  const appName = props.appName || props.name;\n  if (!appName) {\n    throw Error(\n      `single-spa-react was not given an application name as a prop, so it can't make a unique dom element container for the react application`\n    );\n  }\n  const htmlId = `single-spa-application:${appName}`;\n\n  return function defaultDomEl() {\n    let domElement = document.getElementById(htmlId);\n    if (!domElement) {\n      domElement = document.createElement(\"div\");\n      domElement.id = htmlId;\n      document.body.appendChild(domElement);\n    }\n\n    return domElement;\n  };\n}\n\nfunction reactDomRender({ opts, elementToRender, domElement, whenFinished }) {\n  if (\n    [\n      \"createRoot\",\n      \"unstable_createRoot\",\n      \"createBlockingRoot\",\n      \"unstable_createBlockingRoot\",\n    ].indexOf(opts.renderType) >= 0\n  ) {\n    return opts.ReactDOM[opts.renderType](domElement).render(\n      elementToRender,\n      whenFinished\n    );\n  }\n\n  if (opts.renderType === \"hydrate\") {\n    return opts.ReactDOM.hydrate(elementToRender, domElement, whenFinished);\n  }\n\n  // default to this if 'renderType' is null or doesn't match the other options\n  return opts.ReactDOM.render(elementToRender, domElement, whenFinished);\n}\n\nfunction getElementToRender(opts, props) {\n  const rootComponentElement = opts.React.createElement(\n    opts.rootComponent,\n    props\n  );\n\n  let elementToRender = SingleSpaContext\n    ? opts.React.createElement(\n        SingleSpaContext.Provider,\n        { value: props },\n        rootComponentElement\n      )\n    : rootComponentElement;\n\n  if (opts.errorBoundary) {\n    opts.errorBoundaryClass =\n      opts.errorBoundaryClass || createErrorBoundary(opts);\n    elementToRender = opts.React.createElement(\n      opts.errorBoundaryClass,\n      props,\n      elementToRender\n    );\n  }\n\n  return elementToRender;\n}\n\nfunction createErrorBoundary(opts) {\n  // Avoiding babel output for class syntax and super()\n  // to avoid bloat\n  function SingleSpaReactErrorBoundary(props) {\n    // super\n    opts.React.Component.apply(this, arguments);\n\n    this.state = {\n      caughtError: null,\n      caughtErrorInfo: null,\n    };\n\n    SingleSpaReactErrorBoundary.displayName = `SingleSpaReactErrorBoundary(${props.name})`;\n  }\n\n  SingleSpaReactErrorBoundary.prototype = Object.create(\n    opts.React.Component.prototype\n  );\n\n  SingleSpaReactErrorBoundary.prototype.render = function () {\n    if (this.state.caughtError) {\n      return opts.errorBoundary(\n        this.state.caughtError,\n        this.state.caughtErrorInfo,\n        this.props\n      );\n    } else {\n      return this.props.children;\n    }\n  };\n\n  SingleSpaReactErrorBoundary.prototype.componentDidCatch = function (\n    err,\n    info\n  ) {\n    this.setState({\n      caughtError: err,\n      caughtErrorInfo: info,\n    });\n  };\n\n  return SingleSpaReactErrorBoundary;\n}\n","/* This import statement requires a peer or dev dependency on react that is fulfilled at runtime.\n * To avoid duplicate bundling of react, we do not do this inside of single-spa-react.js.\n * We also do not set up the prop types in this file to avoid requiring the user of the library\n * to have prop-types installed and in their browser bundle, since not everyone uses prop types.\n */\nimport React from \"react\";\nimport { SingleSpaContext } from \"./single-spa-react\";\n\nexport default class Parcel extends React.Component {\n  static defaultProps = {\n    wrapWith: \"div\",\n    wrapStyle: {},\n    parcelDidMount: () => {},\n  };\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      hasError: false,\n    };\n\n    if (!props.config) {\n      throw new Error(\n        `single-spa-react's Parcel component requires the 'config' prop to either be a parcel config or a loading function that returns a promise. See https://github.com/single-spa/single-spa-react`\n      );\n    }\n  }\n  componentDidMount() {\n    this.addThingToDo(\"mount\", () => {\n      const mountParcel = this.props.mountParcel || this.mountParcel;\n      if (!mountParcel) {\n        throw new Error(`\n\t\t\t\t  <Parcel /> was not passed a mountParcel prop, nor is it rendered where mountParcel is within the React context.\n\t\t\t\t  If you are using <Parcel /> within a module that is not a single-spa application, you will need to import mountRootParcel from single-spa and pass it into <Parcel /> as a mountParcel prop\t\n\t\t\t\t`);\n      }\n      let domElement;\n      if (this.el) {\n        domElement = this.el;\n      } else {\n        this.createdDomElement = domElement = document.createElement(\n          this.props.wrapWith\n        );\n        Object.keys(this.props.wrapStyle).forEach((key) => {\n          domElement.style[key] = this.props.wrapStyle[key];\n        });\n        this.props.appendTo.appendChild(domElement);\n      }\n      this.parcel = mountParcel(this.props.config, {\n        domElement,\n        ...this.getParcelProps(),\n      });\n      this.parcel.mountPromise.then(this.props.parcelDidMount);\n      return this.parcel.mountPromise;\n    });\n  }\n  componentDidUpdate() {\n    this.addThingToDo(\"update\", () => {\n      if (this.parcel && this.parcel.update) {\n        return this.parcel.update(this.getParcelProps());\n      }\n    });\n  }\n  componentWillUnmount() {\n    this.addThingToDo(\"unmount\", () => {\n      if (this.parcel && this.parcel.getStatus() === \"MOUNTED\") {\n        return this.parcel.unmount();\n      }\n    });\n\n    if (this.createdDomElement) {\n      this.createdDomElement.parentNode.removeChild(this.createdDomElement);\n    }\n\n    this.unmounted = true;\n  }\n  render() {\n    if (this.props.appendTo) {\n      if (SingleSpaContext && SingleSpaContext.Consumer) {\n        return (\n          <SingleSpaContext.Consumer>\n            {(context) => {\n              this.mountParcel = context ? context.mountParcel : null;\n\n              return null;\n            }}\n          </SingleSpaContext.Consumer>\n        );\n      } else {\n        return null;\n      }\n    } else {\n      const children =\n        SingleSpaContext && SingleSpaContext.Consumer ? (\n          <SingleSpaContext.Consumer>\n            {(context) => {\n              this.mountParcel = context ? context.mountParcel : null;\n\n              return null;\n            }}\n          </SingleSpaContext.Consumer>\n        ) : undefined;\n\n      return React.createElement(\n        this.props.wrapWith,\n        {\n          ref: this.handleRef,\n          style: this.props.wrapStyle,\n          className: this.props.wrapClassName,\n        },\n        children\n      );\n    }\n  }\n  handleRef = (el) => {\n    this.el = el;\n  };\n  addThingToDo = (action, thing) => {\n    if (this.state.hasError && action !== \"unmount\") {\n      // In an error state, we don't do anything anymore except for unmounting\n      return;\n    }\n\n    this.nextThingToDo = (this.nextThingToDo || Promise.resolve())\n      .then((...args) => {\n        if (this.unmounted && action !== \"unmount\") {\n          // Never do anything once the react component unmounts\n          return;\n        }\n\n        return thing(...args);\n      })\n      .catch((err) => {\n        this.nextThingToDo = Promise.resolve(); // reset so we don't .then() the bad promise again\n        this.setState({ hasError: true });\n\n        if (err && err.message) {\n          err.message = `During '${action}', parcel threw an error: ${err.message}`;\n        }\n\n        if (this.props.handleError) {\n          this.props.handleError(err);\n        } else {\n          setTimeout(() => {\n            throw err;\n          });\n        }\n\n        // No more things to do should be done -- the parcel is in an error state\n        throw err;\n      });\n  };\n  getParcelProps = () => {\n    const parcelProps = { ...this.props };\n\n    delete parcelProps.mountParcel;\n    delete parcelProps.config;\n    delete parcelProps.wrapWith;\n    delete parcelProps.wrapStyle;\n    delete parcelProps.appendTo;\n    delete parcelProps.handleError;\n    delete parcelProps.parcelDidMount;\n\n    return parcelProps;\n  };\n}\n"],"names":["SingleSpaContext","require","createContext","Parcel","React","Component","props","el","action","thing","_this","state","hasError","nextThingToDo","Promise","resolve","then","unmounted","catch","err","setState","message","handleError","setTimeout","parcelProps","mountParcel","config","wrapWith","wrapStyle","appendTo","parcelDidMount","Error","addThingToDo","domElement","_this2","createdDomElement","document","createElement","Object","keys","forEach","key","style","appendChild","parcel","getParcelProps","mountPromise","_this3","update","_this4","getStatus","unmount","this","parentNode","removeChild","Consumer","context","_this5","children","undefined","ref","handleRef","className","wrapClassName"],"mappings":"gxDAKO,IAAIA,EAAmB,KAM9B,IAOEA,EAAmBC,QAAQ,SAASC,gBACpC,cCXmBC,oPAAeC,aAAMC,uCAM5BC,mIACJA,iBAmGI,SAACC,KACNA,GAAKA,4BAEG,SAACC,EAAQC,GAClBC,EAAKC,MAAMC,UAAuB,YAAXJ,MAKtBK,eAAiBH,EAAKG,eAAiBC,QAAQC,WACjDC,MAAK,eACAN,EAAKO,WAAwB,YAAXT,SAKfC,6BAERS,OAAM,SAACC,WACDN,cAAgBC,QAAQC,YACxBK,SAAS,CAAER,UAAU,IAEtBO,GAAOA,EAAIE,UACbF,EAAIE,0BAAqBb,uCAAmCW,EAAIE,UAG9DX,EAAKJ,MAAMgB,cACRhB,MAAMgB,YAAYH,GAEvBI,YAAW,iBACHJ,KAKJA,kCAGK,eACTK,OAAmBd,EAAKJ,qBAEvBkB,EAAYC,mBACZD,EAAYE,cACZF,EAAYG,gBACZH,EAAYI,iBACZJ,EAAYK,gBACZL,EAAYF,mBACZE,EAAYM,eAEZN,OAlJFb,MAAQ,CACXC,UAAU,IAGPN,EAAMoB,aACH,IAAIK,wRAMPC,aAAa,SAAS,eAQrBC,EAPER,EAAcS,EAAK5B,MAAMmB,aAAeS,EAAKT,gBAC9CA,QACG,IAAIM,+VAMRG,EAAK3B,GACP0B,EAAaC,EAAK3B,IAElB2B,EAAKC,kBAAoBF,EAAaG,SAASC,cAC7CH,EAAK5B,MAAMqB,UAEbW,OAAOC,KAAKL,EAAK5B,MAAMsB,WAAWY,SAAQ,SAACC,GACzCR,EAAWS,MAAMD,GAAOP,EAAK5B,MAAMsB,UAAUa,MAE/CP,EAAK5B,MAAMuB,SAASc,YAAYV,IAElCC,EAAKU,OAASnB,EAAYS,EAAK5B,MAAMoB,UACnCO,WAAAA,GACGC,EAAKW,mBAEVX,EAAKU,OAAOE,aAAa9B,KAAKkB,EAAK5B,MAAMwB,gBAClCI,EAAKU,OAAOE,6EAIhBd,aAAa,UAAU,cACtBe,EAAKH,QAAUG,EAAKH,OAAOI,cACtBD,EAAKH,OAAOI,OAAOD,EAAKF,oFAK9Bb,aAAa,WAAW,cACvBiB,EAAKL,QAAsC,YAA5BK,EAAKL,OAAOM,mBACtBD,EAAKL,OAAOO,aAInBC,KAAKjB,wBACFA,kBAAkBkB,WAAWC,YAAYF,KAAKjB,wBAGhDlB,WAAY,iDAGbmC,KAAK9C,MAAMuB,gBACT7B,GAAoBA,EAAiBuD,SAErCnD,wBAACJ,EAAiBuD,eACf,SAACC,UACAC,EAAKhC,YAAc+B,EAAUA,EAAQ/B,YAAc,KAE5C,QAKN,SAGHiC,EACJ1D,GAAoBA,EAAiBuD,SACnCnD,wBAACJ,EAAiBuD,eACf,SAACC,UACAC,EAAKhC,YAAc+B,EAAUA,EAAQ/B,YAAc,KAE5C,aAGTkC,SAECvD,UAAMiC,cACXe,KAAK9C,MAAMqB,SACX,CACEiC,IAAKR,KAAKS,UACVnB,MAAOU,KAAK9C,MAAMsB,UAClBkC,UAAWV,KAAK9C,MAAMyD,eAExBL,0CAtGavD,iBACG,CACpBwB,SAAU,MACVC,UAAW,GACXE,eAAgB"}